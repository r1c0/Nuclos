//Copyright (C) 2010  Novabit Informationssysteme GmbH
//
//This file is part of Nuclos.
//
//Nuclos is free software: you can redistribute it and/or modify
//it under the terms of the GNU Affero General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.
//
//Nuclos is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU Affero General Public License for more details.
//
//You should have received a copy of the GNU Affero General Public License
//along with Nuclos.  If not, see <http://www.gnu.org/licenses/>.

package org.nuclos.installer.util;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PropUtils {

	private static final Pattern PARAM_PATTERN = Pattern.compile("\\$\\{([^}]*)\\}");

	public static String resolveParameters(String text, Properties params) {
		return resolveParametersImpl(text, params, new ArrayList<String>());
	}

	private static String getProperty(Properties props, String key, String defaultValue, List<String> nesting) {
		if (nesting.contains(key))
			throw new IllegalArgumentException("Recursive property definition for " + key);
		if (!props.containsKey(key))
			return defaultValue;
		String value = props.getProperty(key);
		if (value != null) {
			nesting.add(key);
			value = resolveParametersImpl(value, props, nesting);
			nesting.remove(nesting.size() - 1);
		}
		return value;
	}

	private static String resolveParametersImpl(String text, Properties params, List<String> nesting) {
		StringBuffer sb = new StringBuffer();

		Matcher matcher = PARAM_PATTERN.matcher(text);
		while (matcher.find()) {
			String subProperty = getProperty(params, matcher.group(1), null, nesting);
			if (subProperty == null)
				throw new IllegalArgumentException("Missing property " + matcher.group(1));
			matcher.appendReplacement(sb, Matcher.quoteReplacement(subProperty));
		}
		matcher.appendTail(sb);

		return sb.toString();
	}

	//

	public static void replacePropertyParameters(File file, Properties params) throws IOException {
		SortedProperties props = new SortedProperties();
		InputStream in = new FileInputStream(file);
		try {
			props.load(in);
		} finally {
			in.close();
		}
		replacePropertiesImpl(props, params);
		FileOutputStream os = new FileOutputStream(file);
		try {
			props.store(os, "DO NOT EDIT! Generated by Nuclos Installer");
		} finally {
			os.close();
		}
	}

	public static void replaceTextParameters(File file, Properties params, String encoding) throws IOException {
		Charset charset = (encoding != null) ? Charset.forName(encoding) : Charset.defaultCharset();
		byte[] b = FileUtils.readAll(file);
		String text = new String(b, charset);
		String resolvedText = PropUtils.resolveParameters(text, params);
		b = resolvedText.getBytes(charset);
		FileOutputStream os = new FileOutputStream(file);
		try {
			os.write(b);
		} finally {
			os.close();
		}
	}

	private static void replacePropertiesImpl(Properties props, Properties params) {
		for (Map.Entry<?, Object> e : props.entrySet()) {
			String value = (String) e.getValue();
			if (value != null) {
				try {
					String replacement = PropUtils.resolveParameters(value, params);
					e.setValue(replacement);
				} catch (Exception ex) {
					throw new IllegalArgumentException(e.getKey() + ":" + e.getValue(), ex);
				}
			}
		}
	}

	/**
	 * This class ensures that the key order ({@link Properties#keys()},
	 * esp. used for writing the property file) is lexically sorted.
	 */
	private static class SortedProperties extends Properties {

		private static final long serialVersionUID = 1L;

		@Override
		public synchronized Enumeration<Object> keys() {
			TreeSet<Object> sortedKeys = new TreeSet<Object>();
			for (Enumeration<Object> e = super.keys(); e.hasMoreElements(); )
				sortedKeys.add(e.nextElement());
			return Collections.enumeration(sortedKeys);
		}
	}
}
